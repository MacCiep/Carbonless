c
cc
expect(response.body).to eq(expected_response)
expected_response == response.body
expected_response
response.body
expect(response.body).to(eq(expected_response))
response.body
expected_response
c
JSON.parse(response.body)
response.body
c
expect(response.body).to(eq(ordered_users.to_json))
response.body
ordered_users.pluck(:score)
ordered_users
c
ordered_users.pluck(:score)
response.body
ordered_users
c
user.reload
c
expect { subject }.to change { user.country }.to eq(location.country)
c
user.country
location.country
subject
location.country
user.country
c
session[:points]
user.reload
c
0 || machine.partner.points
points || machine.partner.points
machine.partner
points
c
n
machine.location
machine
c
 client.post("#{build_query_params(travel_session)}")
c
n
c
car_distance
n
c
response
n
build_query_params(travel_session)
c
car_distance
c
 authenticate_user!
c
current_user
c
authenticate_user!
c
params[:range]&.to_f > 50
params[:range]&.to_f
c
continue
response.body
response
c
pagy(scoped_partners)
scoped_partners
c
scoped_partners
pagy(scoped_partners)
c
partner.locations.with_nearby_machines(options[:latitude], options[:longitude]) if options[:latitude] && options[:longitude]
partner.locations
partner
c
test
test = scoped_partners
scoped_partners
c
n
c!
cc
c
Partner.joins(:machines).where(machine_id: machines_ids)
c!
c
cc
n
c
Location.with_nearby_machines(latitude, longitude).pluck(:machine_id).uniq
Location.with_nearby_machines(latitude, longitude).uniq
Location.with_nearby_machines(latitude, longitude)..uniq
Location.with_nearby_machines(latitude, longitude)
Location.with_nearby_machines(latitude, longitude).pluck(:machine_id)
c
n
c
user_have_enough_points?
current_user.users_prizes.new(user_prize_params_create)
c
@prize
current_user.users_prizes.new(user_prize_params_create)
c
n
c
c!
c
c!
c
cc
user
c
authenticated_headers({},nil)
headers
c
current_user
c
current_user
c!
c
current_user
c
c!
c
request
headers
current_user
c
c!
c
login_as(user, scope: :users)
c!
c
user
c
subject
c
n
@prize
c
UsersPrize.find(params[:id])
params[:id]
c
subject
c
c!
c
subject
users_prize_path(user_prize)
user_prize
c
Location.with_nearby_machines(70.0, 70.0)
Location.all
Location.with_nearby_machines(79.0, 79.0)
c
warden.set_user(resource, options.merge!(scope: scope))
n
s
c
n
nn
n
nn
n
nn
n
c
n
c
n
warden.authenticate!(scope: :user, run_callbacks: false)
c
session
sessions
warden.authenticate!(auth_options)
auth_options
session
warden.authenticate!(:jwt, scope: :user, run_callbacks: false)
c
user
c
user
c
user
c
n
c
(@record.created_at + @record.duration.days).in_time_zone("UTC")
@record.duration.days
@record.duration
DateTime.now.in_time_zone("UTC")
(@record.created_at + @record.duration).in_time_zone("UTC")
duration_left?
duration_left?\
@record.active?
c
s
@prize
c
params
configure_account_update_params
c
@user.purchases.last.created_at + TIME_BETWEEN_PURCHASES < verification_time
verification_time
 @user.purchases.last.created_at + TIME_BETWEEN_PURCHASES
TIME_BETWEEN_PURCHASES
@user.purchases.count.zero?
c
n
c
user.purchases
c
e
n
user.purchases.count.zero?
user.purchases.count
user.purchases.count.
@user.purchases
@user
user
useer
c
user.purchases
user.count
c
user.purchases.count
user.purchases
user
@user.purchases.count.zero?
c
s
c
n
@user.purchases.count.zero?
s
validate_purchase_offset
c
validate_purchase_offset
c
validate_purchase_offset
validate_expiration_date
c
EXPIRATION_TIME_LIMIT
verification_time
decrypted_expires.to_datetime.in_time_zone("UTC")
c
validate_expiration_date
validate_purchase_offset
c
Machine.all
machine
