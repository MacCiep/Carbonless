c
@user.purchases.last.created_at + TIME_BETWEEN_PURCHASES < verification_time
verification_time
 @user.purchases.last.created_at + TIME_BETWEEN_PURCHASES
TIME_BETWEEN_PURCHASES
@user.purchases.count.zero?
c
n
c
user.purchases
c
e
n
user.purchases.count.zero?
user.purchases.count
user.purchases.count.
@user.purchases
@user
user
useer
c
user.purchases
user.count
c
user.purchases.count
user.purchases
user
@user.purchases.count.zero?
c
s
c
n
@user.purchases.count.zero?
s
validate_purchase_offset
c
validate_purchase_offset
c
validate_purchase_offset
validate_expiration_date
c
EXPIRATION_TIME_LIMIT
verification_time
decrypted_expires.to_datetime.in_time_zone("UTC")
c
validate_expiration_date
validate_purchase_offset
c
Machine.all
machine
n
s
c
expected_response
response.body
c
response.body
response
c
test
c
PurchaseSerializer.new(purchase, user).call
c
result.success?
result.value
c
PurchaseSerializer.new(result.value, current_user).call
PurchaseSerializer.new(purchase, user).call
result.value
result.success?
c
purchase.save
n
user.purchases.build(machine: machine, purchase_type: machine.service_type_before_type_cast, points: points)
c
n
c
Validator.new(machine, expires, user).call
c
n
user
machine
machine,
expires
c
JSON.parse(response.body)
response.body
c
response.body
response
c
success_status(result.value)
c
result.value
c
n
c
n
c
user.travel_sessions.build(@travel_session_origin_params, machine: machine, purchase_type: machine.service_type_before_type_cast)
@travel_session_origin_params
c
    def call
c
OriginValidator.new(machine_params).call
machine
machine_params
c
exception
n
user.travel_sessions.active.present?
c
user.travel_sessions.active.present?
c
exception
n
s
n
machine.service_type == :travel
machine.service_type == 'travel'
machine.service_type
n
machine.nil?
n
s
handler_params
c
super
c
subject.save
c
machine.service_type_before_type_cast
machine.service_type
machine.service_type.to_i
machine.service_type
machine
c
expires_date
verification_time + EXPIRATION_TIME_LIMIT
verification_time
verification_time < expires_date
c
n
c
n
expires_date
verification_time
verification_time < expires_date
decrypted_expires.to_datetime.in_time_zone("UTC")
c
verification_time
decrypted_expires.to_datetime
c
n
c
n
expires_date = decrypted_expires.to_datetime
decrypted_expires = encryptor.decrypt_and_verify(expires)
encryptor.decrypt_and_verify(expires)
expires
c
exception
n
@user.purchases.count.zero?
s
c
e
n
s
validate_expiration_date
validate_purchase_offset
c
cc
c
Validator.new(machine_params, user).call
c
continue
@user.purchases.first.created_at
@user.purchases.first
@user.purchases
c
x
c
test = Purchase.new(purchase_type: 1, points: 20, machine: Machine.first)
test = Purchase.build(purchase_type: 1, points: 20, machine: Machine.first)
test = @user.purchases.build(purchase_type: 1, points: 20, machine: Machine.first)
@user
c
continue
Purchase.find(1)
Purchase.find(id: 1)
Purchase.first
Purchase.count
Purchase
@user.purchases.ids
@user.purchases.pluck(:id)
c
@user.purchases.count
@user.purchases.pluck(:id)
@user.purchases.ids
@user.purchases
continue
@user.purchases[0]
@user.purchases
@user.foods
@user.purchases.first
@user.purchases
@user.purchases.count
c
@user.purchases.last
@user.purchases.first
@user.purchases.last
@user.purchases.count
@user.purchases
c
cc
c
create(:purchase,  user: user)
create(:purchase, service_type: 'cloth',  user: user)
continue
create(:purchase, service_type: 'cloth',  user: user)
create(:purchase, service_type: 'cloth;,  user: user)
create(:purchase, service_type: :cloth,  user: user)
create(:purchase, user: user)
c
::Purchases::Validator(machine_params, user).call
c
current_session.machine.uuid == machine_uuid
uuid
verification_time > current_session.created_at + SESSION_MAX_LIFETIME
current_session.created_at + SESSION_MAX_LIFETIME
verification_time
c
verification_time
current_session.created_at + SESSION_MAX_LIFETIME
c
Datetime.now
verification_time
current_session.created_at + SESSION_MAX_LIFETIME
SESSION_MAX_LIFETIME
current_session.blank?
c
expires
c
other_machine
machine
c
decrypted_expires
n
c
e
n
uuid
c
current_user.total_carbon_saved.round(2)
c
