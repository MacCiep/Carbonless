q
exchange_item.reload.status_active?
exchange_item.reload.active?
exchange_item.reload.status.to_i
exchange_item.reload.to_i
exchange_item.reload.status
exchange_item.reload.status.to_i
exchange_item.reload.status
subject
q
@exchange_item.reload.status
@exchange_item.activate!
@exchange_item.reload.status
@exchange_item.reload
@exchange_item.status
@exchange_item.activate
q
@exchange_item.activate
@exchange_item.status
@exchange_item
c
expect(response.body).to eq(expected_response.to_json)
q
expected_response.to_json
response.body
expect(response.body).to eq(expected_response.to_json)
c
q
expected_response.to_json
response.body
c
q
@exchange_item.errors.full_messages
@exchange_item.errors
@exchange_item.save
@exchange_item.user
@exchange_item
current_user
@exchange_item
q
params
q
exchange_item_params
@exchange_item.errors.full_messages
@exchange_item.errors
@exchange_item.save
c
q
c
ExchangeItem.count
c
ExchangeItem.count
c
ExchangeItem.count
c
ExchangeItem.count
q
ExchangeItem.count
c
headers
subject
send(method, url, headers: headers) rescue nil
q
y
q
send(method, url, headers: headers) rescue nil
q
send(method, url, headers: headers) rescue nil
q
send(method, url, headers: headers) rescue nil
c
send(method, url, headers: headers)
subject.call
subject
q
subject
send(method, url, headers: headers)
q
send(method, url, headers: headers)
subject
q
send(method, url, headers: headers)
q
subject
response.status
subject
response.status
c
response.status
response
subject
send(method, url, headers: headers) rescue nil
subject
send(method, url, headers: headers)
headers
method
url
ExchangeItem.all
ExchangeItems.all
method
subject.body
subject
c
subject
headers
Time.now
c
response.status
response
c
subject
response
c
JSON.parse(response.body).pluck('history_type')
JSON.parse(response.body).sort_by { |point_history| point_history['created_at'].to_date }
JSON.parse(response.body).sort_by { |point_history| point_history['created_at'] }
JSON.parse(response.body).sort_by { |point_history| point_history.created_at }
JSON.parse(response.body).sort
JSON.parse(response.body)
JSON.parse(response.body).sort(:created_at)
JSON.parse(response.body).sort_by(:created_at)
JSON.parse(response.body).sort_by('created_at')
JSON.parse(response.body).pluck('history_type')
JSON.parse(response.body).pluck(:history_type)
JSON.parse(response.body)
PointsHistory.where(user: user).count
PointsHistory.where(user: user)
PointsHistory.all
PointsHistory.first
PointsHistory.where(history_type: 'prize').first
PointsHistory.where(points_type: 'prize').first
PointsHistory.where(points_type: 'prize')
user_prize.attributes
user_prize.to_h
user_prize.to_hash
user_prize
c
expect(JSON.parse(response.body)).to include(purchase)
JSON.parse(response.body)
expect(response.body).to include(purchase)
purchase
response.body
c
response.body
c
cc
expect(response.body).to eq(expected_response)
expected_response == response.body
expected_response
response.body
expect(response.body).to(eq(expected_response))
response.body
expected_response
c
JSON.parse(response.body)
response.body
c
expect(response.body).to(eq(ordered_users.to_json))
response.body
ordered_users.pluck(:score)
ordered_users
c
ordered_users.pluck(:score)
response.body
ordered_users
c
user.reload
c
expect { subject }.to change { user.country }.to eq(location.country)
c
user.country
location.country
subject
location.country
user.country
c
session[:points]
user.reload
c
0 || machine.partner.points
points || machine.partner.points
machine.partner
points
c
n
machine.location
machine
c
 client.post("#{build_query_params(travel_session)}")
c
n
c
car_distance
n
c
response
n
build_query_params(travel_session)
c
car_distance
c
 authenticate_user!
c
current_user
c
authenticate_user!
c
params[:range]&.to_f > 50
params[:range]&.to_f
c
continue
response.body
response
c
pagy(scoped_partners)
scoped_partners
c
scoped_partners
pagy(scoped_partners)
c
partner.locations.with_nearby_machines(options[:latitude], options[:longitude]) if options[:latitude] && options[:longitude]
partner.locations
partner
c
test
test = scoped_partners
scoped_partners
c
n
c!
cc
c
Partner.joins(:machines).where(machine_id: machines_ids)
c!
c
cc
n
c
Location.with_nearby_machines(latitude, longitude).pluck(:machine_id).uniq
Location.with_nearby_machines(latitude, longitude).uniq
Location.with_nearby_machines(latitude, longitude)..uniq
Location.with_nearby_machines(latitude, longitude)
Location.with_nearby_machines(latitude, longitude).pluck(:machine_id)
c
n
c
user_have_enough_points?
current_user.users_prizes.new(user_prize_params_create)
c
@prize
current_user.users_prizes.new(user_prize_params_create)
c
n
c
c!
c
