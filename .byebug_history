c
super
c
subject.save
c
machine.service_type_before_type_cast
machine.service_type
machine.service_type.to_i
machine.service_type
machine
c
expires_date
verification_time + EXPIRATION_TIME_LIMIT
verification_time
verification_time < expires_date
c
n
c
n
expires_date
verification_time
verification_time < expires_date
decrypted_expires.to_datetime.in_time_zone("UTC")
c
verification_time
decrypted_expires.to_datetime
c
n
c
n
expires_date = decrypted_expires.to_datetime
decrypted_expires = encryptor.decrypt_and_verify(expires)
encryptor.decrypt_and_verify(expires)
expires
c
exception
n
@user.purchases.count.zero?
s
c
e
n
s
validate_expiration_date
validate_purchase_offset
c
cc
c
Validator.new(machine_params, user).call
c
continue
@user.purchases.first.created_at
@user.purchases.first
@user.purchases
c
x
c
test = Purchase.new(purchase_type: 1, points: 20, machine: Machine.first)
test = Purchase.build(purchase_type: 1, points: 20, machine: Machine.first)
test = @user.purchases.build(purchase_type: 1, points: 20, machine: Machine.first)
@user
c
continue
Purchase.find(1)
Purchase.find(id: 1)
Purchase.first
Purchase.count
Purchase
@user.purchases.ids
@user.purchases.pluck(:id)
c
@user.purchases.count
@user.purchases.pluck(:id)
@user.purchases.ids
@user.purchases
continue
@user.purchases[0]
@user.purchases
@user.foods
@user.purchases.first
@user.purchases
@user.purchases.count
c
@user.purchases.last
@user.purchases.first
@user.purchases.last
@user.purchases.count
@user.purchases
c
cc
c
create(:purchase,  user: user)
create(:purchase, service_type: 'cloth',  user: user)
continue
create(:purchase, service_type: 'cloth',  user: user)
create(:purchase, service_type: 'cloth;,  user: user)
create(:purchase, service_type: :cloth,  user: user)
create(:purchase, user: user)
c
::Purchases::Validator(machine_params, user).call
c
current_session.machine.uuid == machine_uuid
uuid
verification_time > current_session.created_at + SESSION_MAX_LIFETIME
current_session.created_at + SESSION_MAX_LIFETIME
verification_time
c
verification_time
current_session.created_at + SESSION_MAX_LIFETIME
c
Datetime.now
verification_time
current_session.created_at + SESSION_MAX_LIFETIME
SESSION_MAX_LIFETIME
current_session.blank?
c
expires
c
other_machine
machine
c
decrypted_expires
n
c
e
n
uuid
c
current_user.total_carbon_saved.round(2)
c
{ carbon_saved: current_user.total_carbon_saved.round(2), points: current_user.points }
c
{ carbon_saved: session[:carbon_saved], points: session[:points] }.to_json
{ carbon_saved: session[:carbon_saved], points: session[:points] }.json
response.body
c
@car_distance.present?
c
n
travel_session.reload.end_latitude
c
travel_session.reload
c
n
TravelSessions::TravelSessionCalculator.new(@car_distance).call
session_update_attributes
n
@car_distance
@car_distance.present?
c
DistanceMatrix::Requests::CalculateDistance.new(current_user, @travel_session).call
c
exception
n
DistanceMatrix::Requests::CalculateDistance.new(current_user, @travel_session).call
c
n
c
TravelSessions::Validator.new(travel_session_params).call
c
DateTime.now
verification_time + 20.minutes
verification_time
expires_date
c
n
s
TravelSessions::Validator.new(travel_session_params).call
c
current_session.machine.uuid == uuid
c
current_session.machine.uuid == uuid
puts 'true' if verification_time > current_session.created_at + SESSION_MAX_LIFETIME
verification_time > current_session.created_at + SESSION_MAX_LIFETIME
c
n
current_session.machine.uuid
uuid
verification_time > current_session.created_at + SESSION_MAX_LIFETIME
current_session.created_at + SESSION_MAX_LIFETIME
verification_time
c
current_session.created_at + SESSION_MAX_LIFETIME
verification_time
c
DateTime.now
current_session.created_at + SESSION_MAX_LIFETIME
current_session.created_at
verification_time
c
ActiveSupport::MessageEncryptor.new(machine.secret).encrypt_and_sign(DateTime.now + 10.minutes)
continue
machine.secret.length
machine.secret.lenght
'362bfb95773afcfd1e6c82fcce9e4a12'.length
'362bfb95773afcfd1e6c82fcce9e4a12'.lenght
ActiveSupport::MessageEncryptor.new('362bfb95773afcfd1e6c82fcce9e4a12').encrypt_and_sign('test')
machine.secret
ActiveSupport::MessageEncryptor.new(machine.secret).encrypt_and_sign('test')
ActiveSupport::MessageEncryptor.new(machine.secret).encrypt_and_sign((DateTime.now + 10.minutes).to_s)
(DateTime.now + 10.minutes).to_s
ActiveSupport::MessageEncryptor.new(machine.secret).encrypt_and_sign((DateTime.now + 10.minutes).to_s)
ActiveSupport::MessageEncryptor.new(machine.secret).encrypt_and_sign(DateTime.now + 10.minutes)
ActiveSupport::MessageEncryptor.new(machine.secret)..encrypt_and_sign
ActiveSupport::MessageEncryptor.new(machine.secret)
c
subject
c
n
c
expect { subject }.to change { user.points }.by(10)
user.reload.total_carbon_saved
c
response_body
c
build_query_params(travel_session)
response_body
c
DistanceMatrix::Requests::CalculateDistance.new(current_user, @travel_session).call
c
n
c
n
TravelSessions::Validator.new(travel_session_params, @travel_session).call
c
n
c
travel_session_position_params.to_hash
travel_session_position_params
c
n
response_body.dig('rows')&.first&.dig('elements')&.first&.dig('distance', 'value')
c
response_body.dig('rows')
response_body.dig('rows'
response_body.dig('rows)
response_body.dig(:row)
response_body
response_body.dig('row')
response_body.dig('row')&
response_body.dig('row')&.first
response_body.dig('row')&.first&.dig('elements')&.first&.dig('distance', 'value')
response_body
c
build_query_params(travel_session)
response_body
c
response_body
c
response_body
c
response_body
continue
car_distance
c
n
